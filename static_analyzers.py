import dis 
import pandas as pd

def function_to_bytecode_table(function):
  """
  - Take a function
  - Disassemble it into bytecode
  - Iterate through each instruction to access all metadata
  - Return a dataframe representing the expanded disassembled instructions
  """
  rows = []
  bytecode_obj = dis.Bytecode(function)
  for instruction_i, instruction in enumerate(bytecode_obj):
    raw_code = bytecode_obj.codeobj.co_code[instruction_i *
                                            2:(instruction_i + 1) * 2]
    byte_pair = [raw_code[0], raw_code[1]]
    rows.append({**instruction._asdict(), "bytes": byte_pair})
  return pd.DataFrame(rows)

def check_for_unused_vars(table):
  """
  Checks a function table for unused variables by comparing opnames and argvals. 
  - Returns a list of variables that have been stored but NOT loaded (meaning it went through function execution declared but not ever used).
  - Returns -1 if no unused variable are found
  """
  #We only care about 2 columns in the generated csv, opname and argval
  # opname: in our case, opname shows us whether a variable was stored (STORE_FAST) or loaded (LOAD_FAST)
  # argval: this simpoly holds the name of the variable

  #Filter the dataframe to only show the rows that have STORE_FAST as the opname
  #Convert to csv once finished (this part may not be necessary but this is the first way I got it to work, so I'll keep it for now)
  storedV_frame = table[table["opname"] == "STORE_FAST"]
  storedV_frame.to_csv()

  #Filter the dataframe to only show the rows that have LOAD_FAST as the opname
  #Convert to csv once finished
  loadedV_frame = table[table["opname"] == "LOAD_FAST"]
  loadedV_frame.to_csv()

  #These lists will be used to process the variables / verify if any are unused
  stored_vars_list = []
  loaded_vars_list = []

  #Store the variable names into their respective lists
  for _, row in storedV_frame.iterrows():
    stored_vars_list += [row["argval"]]

  for _, row in loadedV_frame.iterrows():
    loaded_vars_list += [row["argval"]]

  #If a variable shows up in both lists, that means it was stored AND loaded at some point
  #This list comprehension filters out those duplicates, leaving us with just the unused variables
  unused_vars_list = [
      var for var in stored_vars_list if var not in loaded_vars_list
  ]

  if unused_vars_list:
    return unused_vars_list

  return -1


def get_all_constants(table):
  const_frame = table[table['opname'] == 'LOAD_CONST']
  return const_frame['argval'].tolist()


def find_recursive_function_names(table, function_name):
  load_globals = table[table['opname']=='LOAD_GLOBAL']
  if len(load_globals) > 0:
    recursive_rows = load_globals[load_globals['argval']==function_name]
    if len(recursive_rows) > 0:
      if 'CALL_FUNCTION' in table['opname'].tolist():
        return recursive_rows['argval'].tolist()
  return -1
