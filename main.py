import os
import pandas as pd
import dis

from examples.fibbo import fibonacci_function
from examples.sum import sum_function
from examples.unused import unused_sum_function


def function_to_bytecode_table(function):
  """
  - Take a function
  - Disassemble it into bytecode
  - Iterate through each instruction to access all metadata
  - Return a dataframe representing the expanded disassembled instructions
  """
  rows = []
  bytecode_obj = dis.Bytecode(function)
  for instruction_i, instruction in enumerate(bytecode_obj):
    raw_code = bytecode_obj.codeobj.co_code[instruction_i * 2:(instruction_i + 1) * 2]
    byte_pair = [raw_code[0], raw_code[1]]
    rows.append({**instruction._asdict(), "bytes": byte_pair})
  return pd.DataFrame(rows)


# todo:
# functions that take a bytecode table and annotate based on different kinds of static analysis

os.makedirs("function_tables", exist_ok=True)
for function in [fibonacci_function, sum_function, unused_sum_function]:
  table = function_to_bytecode_table(function)
  table.to_csv(os.path.join("Malware-Final-Project/function_tables", function.__name__ + ".csv"))

#Idea 1 in Ideas.md - Find variables that are never accessed
def check_for_unused_vars(filepath):
  """
  Checks a function table for unused variables by comparing opnames and argvals. 
  - Returns a list of variables that have been stored but NOT loaded (meaning it went through function execution declared but not ever used).
  - Returns -1 if no unused variable are found
  """
  #We only care about 2 columns in the generated csv, opname and argval
  # opname: in our case, opname shows us whether a variable was stored (STORE_FAST) or loaded (LOAD_FAST)
  # argval: this simpoly holds the name of the variable
  df = pd.read_csv(filepath, usecols = ['opname','argval'])

  #Filter the dataframe to only show the rows that have STORE_FAST as the opname
  #Convert to csv once finished (this part may not be necessary but this is the first way I got it to work, so I'll keep it for now)
  storedV_frame = df[df["opname"] == "STORE_FAST"]
  storedV_frame.to_csv()

  #Filter the dataframe to only show the rows that have LOAD_FAST as the opname
  #Convert to csv once finished 
  loadedV_frame = df[df["opname"] == "LOAD_FAST"]
  loadedV_frame.to_csv()

  #These lists will be used to process the variables / verify if any are unused 
  stored_vars_list = []
  loaded_vars_list = []

  #Store the variable names into their respective lists
  for row in storedV_frame._values:
    stored_vars_list += [row[1]]
  
  for row in loadedV_frame._values:
    loaded_vars_list += [row[1]]
  
  #If a variable shows up in both lists, that means it was stored AND loaded at some point
  #This list comprehension filters out those duplicates, leaving us with just the unused variables
  unused_vars_list = [var for var in stored_vars_list if var not in loaded_vars_list ]

  if unused_vars_list:
    return unused_vars_list
  
  return -1

#This will print ['unused, 'unused2']
print( check_for_unused_vars("Malware-Final-Project/function_tables/unused_sum_function.csv") )

#This will print -1
print( check_for_unused_vars("Malware-Final-Project/function_tables/sum_function.csv") )