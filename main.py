import os
import pandas as pd
import dis

from examples.fibbo import fibonacci_function
from examples.sum import sum_function
from examples.unused import unused_sum_function
from examples.insecure_apikey import insecure_apikey_function
from examples.factorial import factorial_function
from examples.recursive_factorial import recursive_factorial_function

from static_analyzers import check_for_unused_vars, get_all_constants, find_recursive_function_names


def function_to_bytecode_table(function):
  """
  - Take a function
  - Disassemble it into bytecode
  - Iterate through each instruction to access all metadata
  - Return a dataframe representing the expanded disassembled instructions
  """
  rows = []
  bytecode_obj = dis.Bytecode(function)
  for instruction_i, instruction in enumerate(bytecode_obj):
    raw_code = bytecode_obj.codeobj.co_code[instruction_i *
                                            2:(instruction_i + 1) * 2]
    byte_pair = [raw_code[0], raw_code[1]]
    rows.append({**instruction._asdict(), "bytes": byte_pair})
  return pd.DataFrame(rows)


# todo:
# functions that take a bytecode table and annotate based on different kinds of static analysis

tables = {}
os.makedirs("function_tables", exist_ok=True)
for function in [
    fibonacci_function, sum_function, unused_sum_function,
    insecure_apikey_function, factorial_function, recursive_factorial_function
]:
  table = function_to_bytecode_table(function)
  table.to_csv(os.path.join("function_tables", function.__name__ + ".csv"))
  tables[function.__name__] = table

#Idea 1 in Ideas.md - Find variables that are never accessed
#This will print ['unused, 'unused2', 'unused3']
print(check_for_unused_vars(tables["unused_sum_function"]))

#This will print -1
print(check_for_unused_vars(tables["sum_function"]))

print(get_all_constants(tables["insecure_apikey_function"]))

print(find_recursive_function_names(tables["fibonacci_function"], "fibbonacci_function"))

print(find_recursive_function_names(tables["factorial_function"], "factorial_function"))

print(find_recursive_function_names(tables["recursive_factorial_function"], "recursive_factorial_function"))