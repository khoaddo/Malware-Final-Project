import os
import pandas as pd
import dis

from examples.fibbo import fibonacci_function
from examples.sum import sum_function


def function_to_bytecode_table(function):
  """
  - Take a function
  - Disassemble it into bytecode
  - Iterate through each instruction to access all metadata
  - Return a dataframe representing the expanded disassembled instructions
  """
  rows = []
  bytecode_obj = dis.Bytecode(function)
  for instruction_i, instruction in enumerate(bytecode_obj):
    raw_code = bytecode_obj.codeobj.co_code[instruction_i *
                                            2:(instruction_i + 1) * 2]
    byte_pair = [raw_code[0], raw_code[1]]
    rows.append({**instruction._asdict(), "bytes": byte_pair})
  return pd.DataFrame(rows)


# todo:
# functions that take a bytecode table and annotate based on different kinds of static analysis

os.makedirs("function_tables", exist_ok=True)
for function in [fibonacci_function, sum_function]:
  table = function_to_bytecode_table(function)
  table.to_csv(os.path.join("function_tables", function.__name__ + ".csv"))
